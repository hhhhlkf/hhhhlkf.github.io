[{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/categories/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/","section":"categories","summary":"","tags":null,"title":"Categories","type":"categories","url":"/categories/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/cv/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/cv/","section":"tags","summary":"","tags":null,"title":"cv","type":"tags","url":"/tags/cv/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/deep-learning/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/deep-learning/","section":"tags","summary":"","tags":null,"title":"deep learning","type":"tags","url":"/tags/deep-learning/","weight":0,"wordcount":0},{"author":null,"categories":["post"],"content":"具体分析了论文中提出的重点网络结构，并对开源代码进行了分析","date":1673403306,"description":"具体分析了论文中提出的重点网络结构，并对开源代码进行了分析","dir":"post\\","excerpt_html":"具体分析了论文中提出的重点网络结构，并对开源代码进行了分析","excerpt_text":"具体分析了论文中提出的重点网络结构，并对开源代码进行了分析","expirydate":-62135596800,"fuzzywordcount":1000,"html":"具体分析了论文中提出的重点网络结构，并对开源代码进行了分析","keywords":null,"kind":"page","lang":"en","lastmod":1673403306,"objectID":"1f995790bed075af690d8fb636e47cd3","permalink":"https://hhhhlkf.github.io/post/fsknet%E8%AE%BA%E6%96%87%E6%A6%82%E8%BF%B0%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","publishdate":"2023-01-11T10:15:06+08:00","readingtime":5,"relpermalink":"/post/fsknet%E8%AE%BA%E6%96%87%E6%A6%82%E8%BF%B0%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","section":"post","summary":"FSKNet的论文分析 提出背景 对早年提出的3D-CNN会导致参数量过大，对系统的训练能力要求较强。因此提出了FSKNet解决这一问题。其中主要参考改进点有两个：\n 设计了3D-CNN和2D-CNN转换模块，利用3D-CNN完成特征提取，同时降低空间和光谱的维数。 在转换后的2D-CNN中，提出了一种选择性核机制，允许每个神经元根据双向输入信息尺度调整感受野大小。  涉及较新的模型结构  2D和3D CNN结合进行特征提取的同时进行降维 可变卷积操作 可分离卷积操作 最后的全局最大池化替换全连接进行加速  网络总体结构 \r其中所有的网络层结构链接如下表格所示：\n\r其中给出了所有的层数，输出维度，链接层和参数，接下来将一一阐述。\n3D-CNN and 2D-CNN conversion modules 本模块由三层3D-Conv、一层可分离3D-Conv和最后经过reshape操作后的2D-Conv组成：\n\r为了避免常规降维时，PCA对其他数据舍弃而导致的信息丢失，本论文采用了一边卷积一边降维的方式，通过设置通道维数的大幅度stride进行降维。\n最后通过reshape+2D Conv进行图像的转换防止图像降维。\nSelective kernel mechanism 下图是其内部结构：\n\r包括了三个重点的结构，可变卷积、注意力机制和可分离卷积。\n可变卷积 \r简要概括\n可变形卷积是指卷积核在每一个元素上额外增加了一个参数方向参数，这样卷积核就能在训练过程中扩展到很大的范围。\n目的\n为了解决在采样过程中卷积核过于固定，不能很好的适应局部空间的采样操作。\n解决方案\n\r上图是可变形卷积的学习过程，首先偏差是通过一个卷积层获得，该卷积层的卷积核与普通卷积核一样。输出的偏差尺寸和输入的特征图尺寸一致。生成通道维度是2N，分别对应原始输出特征和偏移特征。这两个卷积核通过双线性插值后向传播算法同时学习。\n解释\n事实上，可变形卷积单元中增加的偏移量是网络结构的一部分，通过另外一个平行的标准卷积单元计算得到，进而也可以通过梯度反向传播进行端到端的学习。加上该偏移量的学习之后，可变形卷积核的大小和位置可以根据当前需要识别的图像内容进行动态调整，其直观效果就是不同位置的卷积核采样点位置会根据图像内容发生自适应的变化，从而适应不同物体的形状、大小等几何形变。然而，这样的操作引入了一个问题，即需要对不连续的位置变量求导。\n注意力机制 注意力机制主要存在于se block中。\n注意力机制主要通过对当前输入的卷积层进行全局平均池化，并使用激活函数对得到的向量进行激活，再乘到相应的卷积层上，以达到对每个卷积层权重的赋值。\n\r可分离卷积 可分离卷积时经过注意力机制之后的卷积操作，通过可分离卷积进行网络加速，达到减小参数量并保持准确率的效果。\n\r分类器部分 通过全局池化操作将上一层的卷积层从7×7×128转换成了长度为128的向量，并通过全卷积降至种类数，进行分类。\n代码实现部分 网络结构总体设计：\n# 组合模型 class ResnetBuilder(object): @staticmethod def build(input_shape, num_outputs): print(\u0026#39;original input shape:\u0026#39;, input_shape) _handle_dim_ordering() if len(input_shape) !","tags":["HSI classification","cv","deep learning"],"title":"FSKNet——论文概述与代码分析","type":"post","url":"/post/fsknet%E8%AE%BA%E6%96%87%E6%A6%82%E8%BF%B0%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/","weight":0,"wordcount":924},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/hsi-classification/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/hsi-classification/","section":"tags","summary":"","tags":null,"title":"HSI classification","type":"tags","url":"/tags/hsi-classification/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"home","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/","section":"","summary":"","tags":null,"title":"Linexus blog","type":"page","url":"/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/categories/post/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/post/","section":"categories","summary":"","tags":null,"title":"post","type":"categories","url":"/categories/post/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"section","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/post/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/post/","section":"post","summary":"","tags":null,"title":"Posts","type":"post","url":"/post/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673403306,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"taxonomy","lang":"en","lastmod":1673403306,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/","section":"tags","summary":"","tags":null,"title":"Tags","type":"tags","url":"/tags/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673245988,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1673245988,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/database/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/database/","section":"tags","summary":"","tags":null,"title":"database","type":"tags","url":"/tags/database/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1673245988,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1673245988,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/oracle/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/oracle/","section":"tags","summary":"","tags":null,"title":"oracle","type":"tags","url":"/tags/oracle/","weight":0,"wordcount":0},{"author":null,"categories":["post"],"content":"oracle中的sql语句小记","date":1673245988,"description":"oracle中的sql语句小记","dir":"post\\","excerpt_html":"oracle中的sql语句小记","excerpt_text":"oracle中的sql语句小记","expirydate":-62135596800,"fuzzywordcount":500,"html":"oracle中的sql语句小记","keywords":null,"kind":"page","lang":"en","lastmod":1673245988,"objectID":"7dfd68d6a50fc7faf70ff2ddac92cc2e","permalink":"https://hhhhlkf.github.io/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0sql%E8%AF%AD%E5%8F%A5/","publishdate":"2023-01-09T14:33:08+08:00","readingtime":3,"relpermalink":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0sql%E8%AF%AD%E5%8F%A5/","section":"post","summary":"sql语句小记 sql中的函数 sql中有许多的函数，其中包括了单行函数和其他函数。\n单行函数 \r实验表emp样例： 字符函数  大小写函数：upper()、lower()  SELECT \u0026#39;The job id for \u0026#39;||upper(ename)||\u0026#39; is \u0026#39;||lower(job) \u0026#34;EMPLOYEE DETAILS\u0026#34; from emp; \r 将每个单词的首字母转换为大写，其他转换为小写：initcap  SELECT \u0026#39;The job id for \u0026#39;||initcap(ename)||\u0026#39; is \u0026#39;||initcap(job) \u0026#34;EMPLOYEE DETAILS\u0026#34; from emp; \r  字符处理函数 dual表：可以借助dual来满足结构化查询语言格式，作为伪表。\n  拼接函数concat\n  -- 使用“||”来拼接字符串 select \u0026#39;拼接\u0026#39;||\u0026#39;字符串\u0026#39; as str from dual -- 通过concat()函数实现 select concat(\u0026#39;拼接\u0026#39;, \u0026#39;字符串\u0026#39;) as str from dual -- 拼接多个参数 select concat(concat(\u0026#39;拼接\u0026#39;, \u0026#39;多个\u0026#39;), \u0026#39;字符串\u0026#39;) from dual  截取函数substr  select substr(to_char(sysdate, \u0026#39;yyyy-mm-dd HH:mi:ss\u0026#39;), 12, 5) as time from dual  长度函数length  length(\u0026#39;Hello World!","tags":["oracle","database"],"title":"Oracle数据库学习笔记——sql语句函数","type":"post","url":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0sql%E8%AF%AD%E5%8F%A5/","weight":0,"wordcount":457},{"author":null,"categories":["post"],"content":"用navicat可视化操作数据库软件连接Oracle","date":1673188088,"description":"用navicat可视化操作数据库软件连接Oracle","dir":"post\\","excerpt_html":"用navicat可视化操作数据库软件连接Oracle","excerpt_text":"用navicat可视化操作数据库软件连接Oracle","expirydate":-62135596800,"fuzzywordcount":100,"html":"用navicat可视化操作数据库软件连接Oracle","keywords":null,"kind":"page","lang":"en","lastmod":1673188088,"objectID":"8e16979a95fba5308ffdbfa7c3806f8a","permalink":"https://hhhhlkf.github.io/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%A8navicat%E8%BF%9E%E6%8E%A5oracle/","publishdate":"2023-01-08T22:28:08+08:00","readingtime":1,"relpermalink":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%A8navicat%E8%BF%9E%E6%8E%A5oracle/","section":"post","summary":"Navicat连接Oracle 对于navicat的安装就不再过多的叙述了，详情可以参考别的博客或是视频。\n软件版本  Navicat：Navicat Premium 16.0.11 Oracle：Oracle Database 21c Windows：Windows 10 家庭版  配置Navicat  打开Navicat软件，依次点击进入：工具 \u0026ndash;\u0026gt; 选项 \u0026ndash;\u0026gt; 环境 ； 如下图：  \r  进入环境界面后，可以看到OCI环境选项中的 \u0026ndash;\u0026gt; OCI library (oci.dll) * ，将其换为navicat自带的链接库：\n\r重新启动后生效。\n  配置Oracle服务端参数 修改listener.ora 打开Oracle安装文件路径中的文件listener.ora\n\r将listener.ora中的HOST进行修改，如下图所示：\n## 原本 (ADDRESS = (PROTOCOL = TCP)(HOST = {你的IP地址})(PORT = 1521)) ## 改为 (ADDRESS = (PROTOCOL = TCP)(HOST = {你的主机名称})(PORT = 1521)) \r重启服务 并通过win + R打开 service.","tags":["oracle","database"],"title":"Oracle数据库学习笔记——用navicat连接Oracle","type":"post","url":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%94%A8navicat%E8%BF%9E%E6%8E%A5oracle/","weight":0,"wordcount":70},{"author":null,"categories":["post"],"content":"书接上文，下载后创建scott用户，并通过scott.sql进行数据表的创建","date":1673186189,"description":"书接上文，下载后创建scott用户，并通过scott.sql进行数据表的创建","dir":"post\\","excerpt_html":"书接上文，下载后创建scott用户，并通过scott.sql进行数据表的创建","excerpt_text":"书接上文，下载后创建scott用户，并通过scott.sql进行数据表的创建","expirydate":-62135596800,"fuzzywordcount":100,"html":"书接上文，下载后创建scott用户，并通过scott.sql进行数据表的创建","keywords":null,"kind":"page","lang":"en","lastmod":1673186189,"objectID":"8b47fdbca9ce9dcc17408e2f39376c05","permalink":"https://hhhhlkf.github.io/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0scott%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA/","publishdate":"2023-01-08T21:56:29+08:00","readingtime":1,"relpermalink":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0scott%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA/","section":"post","summary":"用户创建 由于在Oracle在11g版本之后不再自动创建sott用户和其学习使用的数据表，因此在学习Oracle过程中需要自己手动导入。\n数据库基础配置 打开数据库界面操作程序 \r登录数据库 在Oracle应用文件夹中找到SQL Plus。点击进入其中：\n\r使用sys /as sysdba后输入用户名和密码，其中用户名使用Oracle的超级管理员用户sys，下图为登陆成功界面:\n\r其中/as sysdba的含义是作为超级管理员登录，当用户拥有超级管理员的权限时，就必须这样登录。密码口令则为安装时设置的密码。\n查询可读写数据库 使用命令：show pdbs; 查询你的可读写库：\n\r可以看到当前ORCLPDB可插入数据库目前符合写要求，但是有可能没有打开。\n打开ORCLPDB数据库 通过命令打开：\nalter pluggable database ORCLPDB open; 打开后可以开始创建scott用户了。\n修改scott.sql 文件路径在：你的21c_home\\rdbms\\admin\\ 下，需要修改指定到你的可读写库里：\n\r#将 CONNECT SCOTT/TIGER #更改为 CONNECT SCOTT/TIGER@你的主机名:监听端口/你的可读写库 #如：CONNECT SCOTT/TIGER@192.168.56.1:1521/orclpdb 导入scott.sql 直接使用 @+你的scott.sql文件路径 ，如：\n@C:\\Users\\Administrator\\Desktop\\21C\\rdbms\\admin\\scott.sql; 解锁scott 查询下当前用户：show user;\n导入之后，可以查询一下是否成功创建scott用户：select username from all_users;\n若创建成功，可以再次查看当前用户：show user;\n然后新开个窗口，或者直接当前窗口conn连接到sysdba上。再然后？对scott进行解锁：\nalter user scott identified by tiger account unlock; 后记 scott用户可以用于后续的登录，其密码为tiger。登陆后可以对齐账户中的表进行sql语句练习。","tags":["oracle","database"],"title":"Oracle数据库学习笔记——scott用户的创建","type":"post","url":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0scott%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA/","weight":0,"wordcount":61},{"author":null,"categories":["post"],"content":"oracle软件的下载和安装","date":1673183312,"description":"oracle软件的下载和安装","dir":"post\\","excerpt_html":"oracle软件的下载和安装","excerpt_text":"oracle软件的下载和安装","expirydate":-62135596800,"fuzzywordcount":100,"html":"oracle软件的下载和安装","keywords":null,"kind":"page","lang":"en","lastmod":1673183312,"objectID":"a358c60625af6b0fd9d7622f15dda10f","permalink":"https://hhhhlkf.github.io/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0oracle%E7%9A%84%E5%AE%89%E8%A3%85/","publishdate":"2023-01-08T21:08:32+08:00","readingtime":1,"relpermalink":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0oracle%E7%9A%84%E5%AE%89%E8%A3%85/","section":"post","summary":"Oracle 数据库的安装 环境概述  操作系统：Windows 10 家庭中文版 21H2 Oracle软件：21c x64 for windows  安装包下载 打开官网：Oracle官网\n看到如下页面：\n\r往下滑找到Download 21c(或者更新的版本和稳定版本)：\n\r点击下载windows版本。\n安装启动 下载完成后直接右键解压或者提取到 **非中文目录下。**建议你直接解压到想安装的目录里，等会儿安装的时候，会直接以xxx_db_home这个文件夹作为程序的根路径，所以放到自己想要的位置上，以后卸载或者其它啥的都方便一些。\n解压完成了之后，打开xxx_db_home文件夹，拉到最后选择“setup”(俩个随便选一个运行)，然后就开始安装了。找到setup.exe并点击：\n\r弹出安装页面：\n指定下载内容 \r指定Oracle用户 我们选择为 Oracle home 的所有者创建一个新的 Windows 用户(如果有则使用现有windows用户)\n\r指定安装位置 \r执行先决条件 \r安装前总结 \r保存响应文件 \r安装产品 如果没有问题就可以安装产品了\n\r安装完成 \r到此Oracle就安装完成了🤣。","tags":["oracle","database"],"title":"Oracle数据库学习笔记——oracle的安装","type":"post","url":"/post/oracle%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0oracle%E7%9A%84%E5%AE%89%E8%A3%85/","weight":0,"wordcount":38},{"author":null,"categories":null,"content":null,"date":1673054935,"description":"","dir":"top\\","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1673054935,"objectID":"cd9612d98d23dc9a533f3478357e0ecf","permalink":"https://hhhhlkf.github.io/top/photos/","publishdate":"2023-01-07T09:28:55+08:00","readingtime":1,"relpermalink":"/top/photos/","section":"top","summary":"精美图片 \r\r\rGreen mon\n\r\r\r\r\r\rFantasy\n\r\r\r\r\r\rLight tower\n\r\r\r\r\r\rXingxuan\n\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r","tags":null,"title":"Photos","type":"top","url":"/top/photos/","weight":0,"wordcount":7},{"author":null,"categories":null,"content":null,"date":1673054935,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"section","lang":"en","lastmod":1673054935,"objectID":"","permalink":"https://hhhhlkf.github.io/top/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/top/","section":"top","summary":"","tags":null,"title":"Tops","type":"top","url":"/top/","weight":0,"wordcount":0},{"author":null,"categories":["Post"],"content":"随机数分组器","date":1662854400,"description":"随机数分组器","dir":"post\\","excerpt_html":"随机数分组器","excerpt_text":"随机数分组器","expirydate":-62135596800,"fuzzywordcount":500,"html":"随机数分组器","keywords":null,"kind":"page","lang":"en","lastmod":1662854400,"objectID":"8db27449560e7a7180b1d563e081745b","permalink":"https://hhhhlkf.github.io/post/%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%8D%A3%E8%AA%89%E8%AF%BE%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E7%BB%84%E5%99%A8/","publishdate":"2022-09-11T00:00:00Z","readingtime":2,"relpermalink":"/post/%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%8D%A3%E8%AA%89%E8%AF%BE%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E7%BB%84%E5%99%A8/","section":"post","summary":"[[message]]\r\r请输入总共人数：\r\r请输入每组人数：\r\r随机分组开始\r\r[[ name[index-1] ]]\r号同学分到了 [[ divideGroup[index-1] ]] 组\n\r\r\r\r#app {\rtext-align: center;\rfont-family: -apple-system, \"Helvetica Neue\", Arial, \"PingFang SC\", \"Hiragino Sans GB\", STHeiti, \"Microsoft YaHei\", \"Microsoft JhengHei\", \"Source Han Sans SC\", \"Noto Sans CJK SC\", \"Source Han Sans CN\", \"Noto Sans SC\", \"Source Han Sans TC\", \"Noto Sans CJK TC\", \"WenQuanYi Micro Hei\", SimSun, sans-serif;\rline-height: 1.1;\rfont-weight: 700;\rfont-size: 36px;\r}\r#rbk {\rheight: 64ch;\rwidth: 80ch;\rmargin: 0 auto;\rborder: 2px solid #282A36;\rborder-radius: 2ch;\r}\r.","tags":["软件工程"],"title":"吉林大学软件工程荣誉课随机数分组器","type":"post","url":"/post/%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%8D%A3%E8%AA%89%E8%AF%BE%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%88%86%E7%BB%84%E5%99%A8/","weight":0,"wordcount":408},{"author":null,"categories":null,"content":null,"date":1662854400,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1662854400,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","section":"tags","summary":"","tags":null,"title":"软件工程","type":"tags","url":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1632121584,"description":"","dir":"top\\","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1632121584,"objectID":"54ccacff97b96806d49760361ef17350","permalink":"https://hhhhlkf.github.io/top/books/","publishdate":"2021-09-20T15:06:24+08:00","readingtime":0,"relpermalink":"/top/books/","section":"top","summary":"","tags":null,"title":"Books","type":"top","url":"/top/books/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1632121570,"description":"","dir":"top\\","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1632121570,"objectID":"104f9431647fd5dcb14e8d0947747fa9","permalink":"https://hhhhlkf.github.io/top/archive/","publishdate":"2021-09-20T15:06:10+08:00","readingtime":0,"relpermalink":"/top/archive/","section":"top","summary":"","tags":null,"title":"Archive","type":"top","url":"/top/archive/","weight":0,"wordcount":0},{"author":null,"categories":["post"],"content":"第一次上机实验题解","date":1632096000,"description":"第一次上机实验题解","dir":"post\\","excerpt_html":"第一次上机实验题解","excerpt_text":"第一次上机实验题解","expirydate":-62135596800,"fuzzywordcount":500,"html":"第一次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"3616987838be9efe56d0877727579eb2","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":3,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第一次上机实验 一、7—1重复计数 在一个有限的正整数序列中，有些数会多次重复出现。请你统计每个数的出现次数， 然后按数字在序列中第一次出现的位置顺序输出数及其次数。\n\r输入格式: 第1行，1个整数N，表示整数的个数，(1≤N≤50000)。\n第2行，N个正整数，每个整数x 都满足 1 ≤ x ≤2000000000。\n输出格式: 若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。 输入样例:\n在这里给出一组输入。例如：\n12 8 2 8 2 2 11 1 1 8 1 13 13 输出样例:\n在这里给出相应的输出。例如：\n8 3 2 3 11 1 1 3 13 2 方法：\n这里直接推荐使用C++STL库中的map容器，数据在map容器中存储结构是红黑树，其操作函数中find``count在查找过程中均为O(nlogn) 不超出这道题的时间限制，且退化性不强，下面是代码：\n#include\u0026lt;iostream\u0026gt;#include\u0026lt;map\u0026gt;using namespace std; int a[50010]; int main() { int n; cin\u0026gt;\u0026gt;n; map\u0026lt;int,int\u0026gt;m;//定义map容器，key值为所给数字值，value值为所给计数值  int count1=0; int n1; for(int i=0;i\u0026lt;n;i++) { cin\u0026gt;\u0026gt;n1; map\u0026lt;int,int\u0026gt;::iterator pos=m.find(n1); if(pos!=m.end())//没有该数字  { pos-\u0026gt;second++; } else { m.","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第一次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":439},{"author":null,"categories":["Post"],"content":"第七次上机实验题解","date":1632096000,"description":"第七次上机实验题解","dir":"post\\","excerpt_html":"第七次上机实验题解","excerpt_text":"第七次上机实验题解","expirydate":-62135596800,"fuzzywordcount":1000,"html":"第七次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"34a4abcf390d1d227b5cde01464647fd","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":5,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第七次上机实验 一.7-1 序列调度 (100 分) 有一个N个数的序列A：1，2，……，N。有一个后进先出容器D，容器的容量为C。如果给出一个由1到N组成的序列，那么可否由A使用容器D的插入和删除操作得到。\n输入格式: 第1行，2个整数T和C，空格分隔，分别表示询问的组数和容器的容量，1≤T≤10，1≤C≤N。\n第2到T+1行，每行的第1个整数N，表示序列的元素数，1≤N≤10000。接下来N个整数，表示询问的序列。\n输出格式: T行。若第i组的序列能得到，第i行输出Yes；否则，第i行输出No,1≤i≤T。\n输入样例: 在这里给出一组输入。例如：\n2 2 5 1 2 5 4 3 4 1 3 2 4 输出样例: 在这里给出相应的输出。例如：\nNo Yes 作者 谷方明 单位 吉林大学 代码长度限制 16 KB 时间限制 100 ms 内存限制 10 MB\n思路： 本题为模拟题，模拟栈的出入，先创建一个栈，循环输入给定序列的每一个元素，每输入一个数字，就从==未入过栈==的最小元素开始入栈，一直到当前数字入栈之后截至，然后弹出栈顶元素，当栈顶元素和当前元素不匹配时，flag置为false,然后等到输入完毕，输出判断结果。\n操作： 1.引入pre指针，记录未入栈的最小元素。在每次循环结束后，用当前输入元素pre=ans+1进行更新，在pre\u0026gt;之后的ans后，入栈将停止。 2.入栈判断问题：在本程序中遇到样例如：\n1 10000 1 10000 2 9999 3 9998 4 9997 5 9996 6 9995..... 在入栈不判断时，就会爆栈，导致段错误。\n代码如下： #include\u0026lt;iostream\u0026gt;#include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;using namespace std; int SS[10001]; int top = 0; int pre = 1; bool flag = true; int main() { int Size, n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;Size); for (int i = 1; i \u0026lt;= n; i++) { int num = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); for (int j = 1; j \u0026lt;= num; j++) { int ans=0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;ans); if(flag==true)//如果已经判断结束，就不再压栈，避免爆栈  for (int k = pre; k \u0026lt;= ans; k++) { SS[++top] = k; } if (top \u0026gt; Size)flag = false; if (SS[top] !","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第七次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":939},{"author":null,"categories":["Post"],"content":"第三次上机实验题解","date":1632096000,"description":"第三次上机实验题解","dir":"post\\","excerpt_html":"第三次上机实验题解","excerpt_text":"第三次上机实验题解","expirydate":-62135596800,"fuzzywordcount":1300,"html":"第三次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"84c73d9301f2a6f32c8a961a06ec5ef0","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":6,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第三次上机实验 7-1 二叉树最长路径 (100 分) 给定一棵二叉树T，求T中的最长路径的长度，并输出此路径上各结点的值。若有多条最长路径，输出最右侧的那条。\n输入格式: 第1行，1个整数n，表示二叉树有n个结点， 1≤n≤100000.\n第2行，2n+1个整数，用空格分隔，表示T的扩展先根序列， -1表示空指针，结点用编号1到n表示。\n输出格式: 第1行，1个整数length，length表示T中的最长路径的长度。\n第2行，length+1个整数，用空格分隔，表示最右侧的最长路径。\n输入样例: 在这里给出一组输入。例如：\n5 1 2 -1 -1 3 4 -1 -1 5 -1 -1 输出样例: 在这里给出相应的输出。例如：\n2 1 3 5 考察方法： 本题考查树的基本运算，包括： 建立一棵二叉树``遍历树``求树的深度 思路：题中所给按照先根遍历建树，然后按照递归遍历求出高度，这里是可以用递归的，只要先求出每个结点的高度 再存入数组下标为树节点data所对应的值，即可保存在之后输出路径的时候可以直接查找比较。\n下面就是代码：\n建树： struct TNode { ElementType Data; BinTree Left; BinTree Right; };//树节点 BinTree CreatBinTree() { int num; BinTree t = NULL; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); if (num == -1) { return NULL; }//递归出口  t = (BinTree)malloc(sizeof(struct TNode)); t-\u0026gt;Data = num; t-\u0026gt;Left = CreatBinTree();//创建左子树  t-\u0026gt;Right = CreatBinTree();//创建右子树  return t; } 求深度： int height(BinTree T) { if (T == NULL) { return -1; } int hl = height(T-\u0026gt;Left);//求取左子树  int hr = height(T-\u0026gt;Right);//求取右子树  if (hl \u0026gt; hr) { d[T-\u0026gt;Data] = hl + 1; return hl + 1; } else { d[T-\u0026gt;Data] = hr + 1; return hr + 1; } } 求路径： void path(BinTree T) { while (T !","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第三次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":1204},{"author":null,"categories":["Post"],"content":"第二次上机实验题解","date":1632096000,"description":"第二次上机实验题解","dir":"post\\","excerpt_html":"第二次上机实验题解","excerpt_text":"第二次上机实验题解","expirydate":-62135596800,"fuzzywordcount":700,"html":"第二次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"f7c1439fa09b649348f4ce598f80a639","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":4,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第二次上机实验 7-1 数列查询 已知数列的通项公式为:\nf(n) = f(n-1)*11/10，f[1]=10. 通项从左向右计算，*和/分别表示整数乘法和除法。 现在，要多次查询数列项的值。\n输入格式: 第1行，1个整数q，表示查询的次数， 1≤q≤10000. 第2至q+1行，每行1个整数i，表示要查询f(i)的值。\n输入样例: 在这里给出一组输入。例如：\n3 1 2 3 输出样例： 在这里给出相应的输出。例如：\n10 11 12 作者 谷方明 单位 吉林大学 代码长度限制 16 KB 时间限制 10 ms 内存限制 1 MB 解法一： 在考场上时，没有考虑到这数字乘起来会有那么大，因此我直接开数组去存每个数量级的(11⁄10)^10，并且竟然把上式看成是double类型😅😅😅。\n解法二： 和上种方法类似，考虑到数字较大我们不妨试一试，f[202]=195422668， f[203]=-214531794 好家伙😏 只要202位的数组就行， 那么，不妨循环存入相应次方的下标数组中，之后直接查找，代码如下：\n#include\u0026lt;cstdio\u0026gt;using namespace std; int num[10003]; int main() { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int sum=10; for(int i=1;i\u0026lt;=190;i++) { num[i]=sum; sum*=11; sum/=10; }//循环计数  int num1; for(int i=1;i\u0026lt;=n;i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;num1); printf(\u0026#34;%d\\n\u0026#34;,num[num1]); }//查找输出  return 0; } 7-2 稀疏矩阵之和 矩阵A和B都是稀疏矩阵。请计算矩阵的和A+B.","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第二次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":659},{"author":null,"categories":["Post"],"content":"第五次上机实验题解","date":1632096000,"description":"第五次上机实验题解","dir":"post\\","excerpt_html":"第五次上机实验题解","excerpt_text":"第五次上机实验题解","expirydate":-62135596800,"fuzzywordcount":1400,"html":"第五次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"739aeaa861e64c35b90b2925a5d2cd66","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":7,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第五次上机实验 7-1 图的深度优先搜索I (100 分) 无向图 G 有 n 个顶点和 m 条边。求图G的深度优先搜索树(森林)以及每个顶点的发现时间和完成时间。每个连通分量从编号最小的结点开始搜索，邻接顶点选择顺序遵循边的输入顺序。\n在搜索过程中，第一次遇到一个结点，称该结点被发现；一个结点的所有邻接结点都搜索完，该结点的搜索被完成。深度优先搜索维护一个时钟，时钟从0开始计数，结点被搜索发现或完成时，时钟计数增1，然后为当前结点盖上时间戳。一个结点被搜索发现和完成的时间戳分别称为该结点的发现时间和完成时间。\n输入格式: 第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.\n第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.\n输出格式: 第1到n行，每行两个整数di和fi，用空格分隔，表示第i个顶点的发现时间和完成时间1≤i≤n 。\n第n+1行，1个整数 k ，表示图的深度优先搜索树(森林)的边数。\n第n+2到n+k+1行，每行两个整数u和v,表示深度优先搜索树(森林)的一条边\u0026lt;u,v\u0026gt;，边的输出顺序按 v 结点编号从小到大。 作者 : 谷方明 单位: 吉林大学 代码长度限制:16 KB 时间限制:200 ms 内存限制:10 MB\n输入样例: 在这里给出一组输入。例如：\n6 5 1 3 1 2 2 3 4 5 5 6 输出样例: 在这里给出相应的输出。例如：\n1 6 3 4 2 5 7 12 8 11 9 10 4 3 2 1 3 4 5 5 6 思路：==题目要看懂==。 1.","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第五次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":1302},{"author":null,"categories":["Post"],"content":"第六次上机实验题解","date":1632096000,"description":"第六次上机实验题解","dir":"post\\","excerpt_html":"第六次上机实验题解","excerpt_text":"第六次上机实验题解","expirydate":-62135596800,"fuzzywordcount":1000,"html":"第六次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"a81b54f8b5aa2e7b1a874c0f565e147e","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":5,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第六次上机实验 7-1 高精度数加法 (100 分) 高精度数是指大大超出了标准数据类型能表示的范围的数，例如10000位整数。很多计算问题的结果都很大，因此，高精度数极其重要。\n一般使用一个数组来存储高精度数的所有数位，数组中的每个元素存储该高精度数的1位数字或多位数字。 请尝试计算：N个高精度数的加和。这个任务对于在学习数据结构的你来说应该是小菜一碟。 。\n输入格式: 第1行，1个整数N，表示高精度整数的个数，(1≤N≤10000)。\n第2至N+1行，每行1个高精度整数x, x最多100位。\n输出格式: 1行,1个高精度整数，表示输入的N个高精度数的加和。\n输入样例: 在这里给出一组输入。例如\n3 12345678910 12345678910 12345678910 输出样例: 在这里给出相应的输出。例如\n37037036730 思路：高精度加法，通过字符数组形式输入，将数组倒置遍历相加，存入整型数组中，最后倒着输出结果。(本题目没有负数，可以放心按照正数处理。)我的代码为负数与正数均可处理。\n代码如下： //#pragma warning(disable:4996) #include\u0026lt;cstdio\u0026gt;#include\u0026lt;cstring\u0026gt;#include\u0026lt;iostream\u0026gt;#include\u0026lt;queue\u0026gt;#include\u0026lt;vector\u0026gt;using namespace std; char num1[101]; char num2[101]; int num[1000100]; int numm[1000100]; int len1 = 0; int len2 = 0; bool flag = true; void Plus1(char*n)//对正数的相加 { int j = 1; int ans = 0; for (int i = strlen(n) - 1; i \u0026gt;= 0; i--, j++) { int d = num[j] + (n[i] - \u0026#39;0\u0026#39;) + ans; if (d \u0026gt;= 10) { ans = 1; num[j] = d % 10; } else { num[j] = d; ans = 0; } } num[j] += ans; while (num[j]\u0026gt;= 10) { num[j] -= 10; num[++j]++; } len1 = max(len1, j); } void Plus2(char*n)//对负数的相加 { int j = 1; int ans = 0; for (int i = strlen(n) - 1; i \u0026gt;=1; i--, j++) { int d = numm[j] + (n[i] - \u0026#39;0\u0026#39;) + ans; if (d \u0026gt;= 10) { ans = 1; numm[j] = d % 10; } else { numm[j] = d; ans = 0; } } numm[j] += ans; while (numm[j] \u0026gt;= 10) { numm[j]-= 10; numm[++j]++; } len2 = max(len2, j); } void Minus(int*n1,int*n2,int len1,int len2)//大和减小和函数 { int ans = 0; for (int i = 1; i \u0026lt;= len1; i++) { int d = n1[i] - n2[i] + ans; if (d \u0026lt; 0) { ans = -1; n1[i] = d + 10; } else { ans = 0; n1[i] = d; } } int j = len1; while (n1[j] == 0) j--; if (!","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第六次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":950},{"author":null,"categories":["Post"],"content":"第四次上机实验题解","date":1632096000,"description":"第四次上机实验题解","dir":"post\\","excerpt_html":"第四次上机实验题解","excerpt_text":"第四次上机实验题解","expirydate":-62135596800,"fuzzywordcount":1000,"html":"第四次上机实验题解","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"7d19d5836d414b0e91e9dc217c7abfb6","permalink":"https://hhhhlkf.github.io/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","publishdate":"2021-09-20T00:00:00Z","readingtime":5,"relpermalink":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","section":"post","summary":"JLU数据结构荣誉课——第四次上机实验 7-1 连通分量 (100 分) 无向图 G 有 n 个顶点和 m 条边。求 G 的连通分量的数目。 输入格式: 第1行，2个整数n和m，用空格分隔，分别表示顶点数和边数， 1≤n≤50000， 1≤m≤100000.\n第2到m+1行，每行两个整数u和v，用空格分隔，表示顶点u到顶点v有一条边，u和v是顶点编号，1≤u,v≤n.\n输出格式: 1行，1个整数，表示所求连通分量的数目。\n输入样例: 在这里给出一组输入。例如：\n6 5 1 3 1 2 2 3 4 5 5 6 输出样例: 在这里给出相应的输出。例如：\n2 作者 谷方明 单位 吉林大学 代码长度限制 16 KB 时间限制 200 ms 内存限制 10 MB\n思路：利用并查集，最后统计并查集个数，及father数组中存的值依旧为零的元素，得到答案。\n#include\u0026lt;cstdio\u0026gt;using namespace std; int father[100001]; int find(int v) { if (father[v] == 0) return v; else return find(father[v]); } void Union(int x,int y) { int fx = find(x); int fy = find(y); if (fx !","tags":["数据结构题解"],"title":"JLU数据结构荣誉课——第四次上机实验","type":"post","url":"/post/jlu%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%8D%A3%E8%AA%89%E8%AF%BE%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","weight":0,"wordcount":934},{"author":null,"categories":null,"content":null,"date":1632096000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1632096000,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/music/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/music/","section":"tags","summary":"","tags":null,"title":"MUSIC","type":"tags","url":"/tags/music/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1632096000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1632096000,"objectID":"","permalink":"https://hhhhlkf.github.io/categories/music/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/categories/music/","section":"categories","summary":"","tags":null,"title":"Music","type":"categories","url":"/categories/music/","weight":0,"wordcount":0},{"author":null,"categories":["Music"],"content":" 音乐","date":1632096000,"description":" 音乐","dir":"post\\","excerpt_html":" 音乐","excerpt_text":" 音乐","expirydate":-62135596800,"fuzzywordcount":100,"html":" 音乐","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"c82dd9e259c5245105b87a0610566459","permalink":"https://hhhhlkf.github.io/post/nzk/","publishdate":"2021-09-20T00:00:00Z","readingtime":1,"relpermalink":"/post/nzk/","section":"post","summary":"\r\r1.Binary-Star ——by SawanoHiroyuki[nZk]\r\r2.Tranquility ——by SawanoHiroyuki[nZk]\r\r3.UNICORN ——by 澤野弘之\r\r4.ViEW ——by mizuki(瑞葵)/SawanoHiroyuki[nZk]\r\r5.ninelie\u0026lt;cry-v\u0026gt; ——by SawanoHiroyuki[nZk]\r\r6.EARth ——by 澤野弘之\r\r7.Tot Musica ——by Ado\r\r8.counter・attack-m’aenkaind ——by 澤野弘之\r\r9.Roads to Ride ——by 澤野弘之\r\r10.ətˈæk 0N tάɪtn\u0026lt;TFSv\u0026gt;——by 澤野弘之\r\r","tags":["MUSIC"],"title":"nzk的音乐","type":"post","url":"/post/nzk/","weight":0,"wordcount":34},{"author":null,"categories":null,"content":null,"date":1632096000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1632096000,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/","section":"tags","summary":"","tags":null,"title":"数学建模","type":"tags","url":"/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":1632096000,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"term","lang":"en","lastmod":1632096000,"objectID":"","permalink":"https://hhhhlkf.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/","section":"tags","summary":"","tags":null,"title":"数据结构题解","type":"tags","url":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98%E8%A7%A3/","weight":0,"wordcount":0},{"author":null,"categories":["Post"],"content":"数学建模算法","date":1632096000,"description":"数学建模算法","dir":"post\\","excerpt_html":"数学建模算法","excerpt_text":"数学建模算法","expirydate":-62135596800,"fuzzywordcount":100,"html":"数学建模算法","keywords":null,"kind":"page","lang":"en","lastmod":1632096000,"objectID":"233f599bfb6d36f34b8e2504b277e01e","permalink":"https://hhhhlkf.github.io/post/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/","publishdate":"2021-09-20T00:00:00Z","readingtime":1,"relpermalink":"/post/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/","section":"post","summary":"啥都没有就是玩","tags":["数学建模"],"title":"模拟退火算法","type":"post","url":"/post/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/","weight":0,"wordcount":1},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"search\\","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8946788897930c0c0c39fbfcd30ff2e4","permalink":"https://hhhhlkf.github.io/search/placeholder/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/search/placeholder/","section":"search","summary":"","tags":null,"title":"","type":"search","url":"/search/placeholder/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"top\\","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"7a0da914bde98a7d3fcc7f6c5886633c","permalink":"https://hhhhlkf.github.io/top/about/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/top/about/","section":"top","summary":"LiKefan is a JLUer,from software collage.","tags":null,"title":"","type":"top","url":"/top/about/","weight":0,"wordcount":6},{"author":null,"categories":null,"content":null,"date":-62135596800,"description":"","dir":"","excerpt_html":null,"excerpt_text":null,"expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://hhhhlkf.github.io/search/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/search/","section":"search","summary":"","tags":null,"title":"Searches","type":"search","url":"/search/","weight":0,"wordcount":0}]